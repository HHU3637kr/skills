---
name: spec-debugger
description: 诊断并修复 Spec 执行过程中发现的问题。当 spec-executor 或 spec-updater 执行后出现问题、bug、或 plan.md 中未考虑到的情况时使用。不修改已确认的 plan.md，而是创建独立的诊断文档（debug-xxx.md）和修复总结（debug-xxx-fix.md），保持设计的可追溯性。
allowed-tools: Read, Grep, Glob, Edit, Write, Bash, LSP
---

# Spec Debugger

## 概述

这个 Skill 用于诊断和修复 Spec 执行过程中发现的问题。它遵循「不修改已确认设计」的原则，通过创建独立的诊断文档来记录问题和修复过程，保持完整的可追溯性。

## 适用场景

### 使用 spec-debugger 的情况

- ✅ spec-executor 执行后发现实现有 bug
- ✅ 运行时出现 plan.md 中未预见的问题
- ✅ 测试通过但实际使用时发现问题
- ✅ 依赖环境或配置导致的问题

### 不使用 spec-debugger 的情况

- ❌ 需要添加新功能（使用 `spec-updater`）
- ❌ 需要重新设计（创建新的 `plan.md`）
- ❌ 代码质量改进/重构（使用 `spec-refactor`，待实现）

## 核心原则

### 1. 不修改已确认的 plan.md

> [!important] 设计完整性
> plan.md 是已经用户确认的设计文档，不应因为执行问题而被修改。问题和修复应作为补充文档记录。

**正确做法**：
- ✅ 创建 debug-xxx.md 记录问题
- ✅ 创建 debug-xxx-fix.md 记录修复
- ✅ 在文档中引用 plan.md 的相关章节

**错误做法**：
- ❌ 直接修改 plan.md 添加遗漏的内容
- ❌ 删除 plan.md 中"有问题"的设计

### 2. 用户确认（必须执行）

> [!important] 必须使用 AskUserQuestion 工具等待用户确认
> 完成诊断文档后，**必须**使用 `AskUserQuestion` 工具等待用户确认诊断结果。

```python
# 生成 debug-xxx.md 后调用
AskUserQuestion(
    questions=[{
        "question": "问题诊断文档已创建，诊断结果是否正确？",
        "header": "确认诊断",
        "multiSelect": false,
        "options": [
            {
                "label": "诊断正确，继续修复",
                "description": "诊断结果准确，可以开始执行修复"
            },
            {
                "label": "诊断有误",
                "description": "诊断结果需要调整，请说明问题"
            }
        ]
    }]
)
```

### 3. 可追溯性

每个诊断文档必须：
- 关联到原始 plan.md
- 记录问题现象和复现步骤
- 分析根因与 plan.md 的关系
- 记录修复方案和验证结果

## 工作流程

```
发现问题
    ↓
spec-debugger 诊断问题
    ↓
创建 debug-xxx.md（诊断文档）
    ↓
用户确认诊断
    ↓
执行修复
    ↓
创建 debug-xxx-fix.md（修复总结）
    ↓
用户确认修复
    ↓
完成（考虑是否记录到 memory）
```

### 详细步骤

```
问题诊断与修复流程：
- [ ] 步骤 1：收集问题信息
- [ ] 步骤 2：检索历史经验（调用 exp-search）
- [ ] 步骤 3：复现并定位问题
- [ ] 步骤 4：分析根因
- [ ] 步骤 5：创建 debug-xxx.md 诊断文档
- [ ] 步骤 6：等待用户确认诊断
- [ ] 步骤 7：设计修复方案
- [ ] 步骤 8：执行修复
- [ ] 步骤 9：验证修复结果
- [ ] 步骤 10：创建 debug-xxx-fix.md 修复总结
- [ ] 步骤 11：等待用户确认修复
```

## 步骤详解

### 步骤 1：收集问题信息

**操作**：
1. 了解问题现象（错误信息、异常行为）
2. 确认问题发生的上下文（什么操作触发）
3. 读取相关的 plan.md 和 summary.md

**信息收集清单**：
- [ ] 错误信息或异常行为描述
- [ ] 触发问题的操作步骤
- [ ] 预期行为 vs 实际行为
- [ ] 相关日志或截图
- [ ] 环境信息（如相关）

### 步骤 2：检索历史经验

**目的**：在开始诊断前，检索相关的历史经验，看是否有类似问题的解决方案。

**操作**：
1. 根据问题现象的关键词，调用 `/exp-search <关键词>` 检索相关经验
2. 如有相关经验，阅读详情并参考历史解决方案

### 步骤 3：复现并定位问题

**操作**：
1. 尝试复现问题
2. 使用日志、调试工具定位问题代码
3. 确认问题的边界条件

**定位技巧**：
```bash
# 查看相关日志
tail -f logs/app.log

# 添加调试输出
print(f"DEBUG: {variable}")

# 运行特定测试
pytest tests/test_xxx.py -v -s
```

### 步骤 4：分析根因

**分析维度**：

| 类型 | 说明 | 示例 |
|------|------|------|
| **设计遗漏** | plan.md 未考虑的边界情况 | 未处理空值输入 |
| **实现偏差** | 实现与 plan.md 不一致 | 参数类型错误 |
| **环境问题** | 依赖、配置、版本问题 | 库版本不兼容 |
| **集成问题** | 模块间交互问题 | 接口返回格式不匹配 |

**关键问题**：
- 这个问题是 plan.md 的设计问题，还是实现问题？
- 修复这个问题需要改变设计吗？
- 这个问题会影响其他功能吗？

### 步骤 5：创建 debug-xxx.md 诊断文档

**操作**：
1. 在 Spec 目录下创建 debug-xxx.md
2. 使用下方模板填写诊断内容
3. **撰写时直接应用 Obsidian 格式优化**

**命名规范**：
- `debug-001.md`、`debug-002.md`（按发现顺序编号）
- 如果问题有明确主题：`debug-001-websocket-timeout.md`

**Frontmatter 格式（必须）**：

```yaml
---
title: 问题诊断-简述
type: debug
category: 与 plan.md 相同
status: 未确认
severity: 高/中/低
created: YYYY-MM-DD
plan: "[[plan]]"
tags:
  - spec
  - debug
---
```

**Frontmatter 字段说明**：

| 字段 | 必填 | 说明 | 可选值 |
|------|------|------|--------|
| `title` | 是 | 诊断标题 | - |
| `type` | 是 | 文档类型 | `debug` |
| `category` | 是 | 分类目录 | 与 plan.md 相同 |
| `status` | 是 | 当前状态 | `未确认`/`已确认`/`已修复` |
| `severity` | 是 | 严重程度 | `高`/`中`/`低` |
| `created` | 是 | 创建日期 | `YYYY-MM-DD` 格式 |
| `plan` | 是 | 关联的 plan | `"[[plan]]"` |
| `tags` | 是 | 标签列表 | 至少包含 `spec` 和 `debug` |

**诊断文档模板**：

```markdown
# 问题诊断

## 1. 问题概述

### 1.1 问题现象
[描述用户看到的问题表现]

### 1.2 预期行为
[描述正确的行为应该是什么]

### 1.3 严重程度
- **级别**：高/中/低
- **影响范围**：[受影响的功能/用户]

---

## 2. 复现步骤

1. [步骤 1]
2. [步骤 2]
3. [步骤 3]
4. **结果**：[问题现象]

### 2.1 环境信息
- **操作系统**：
- **Python 版本**：
- **相关依赖版本**：

---

## 3. 根因分析

### 3.1 问题定位
- **问题代码位置**：`src/xxx/xxx.py:行号`
- **问题类型**：设计遗漏 / 实现偏差 / 环境问题 / 集成问题

### 3.2 根因说明
[详细说明为什么会发生这个问题]

### 3.3 与 plan.md 的关系

> [!note] 设计关联
> 此问题与 [[plan]] 的关系：
> - plan.md 章节 X.X 中未考虑 [某种情况]
> - 或：实现偏离了 plan.md 章节 X.X 的设计

---

## 4. 修复方案

### 4.1 方案描述
[描述如何修复这个问题]

### 4.2 修改范围
- [ ] `src/xxx/xxx.py` - [修改说明]
- [ ] `tests/xxx.py` - [新增测试]

### 4.3 风险评估
- **是否影响其他功能**：是/否
- **是否需要回归测试**：是/否

---

## 5. 文档关联

- 设计文档: [[plan|设计方案]]
- 实现总结: [[summary|实现总结]]
```

### 步骤 6：等待用户确认诊断

**操作**：
1. 使用 `AskUserQuestion` 工具等待用户确认诊断文档

```python
AskUserQuestion(
    questions=[{
        "question": "问题诊断文档已创建，诊断结果是否正确？",
        "header": "确认诊断",
        "multiSelect": false,
        "options": [
            {
                "label": "诊断正确，继续修复",
                "description": "诊断结果准确，可以开始执行修复"
            },
            {
                "label": "诊断有误",
                "description": "诊断结果需要调整，请说明问题"
            }
        ]
    }]
)
```

**响应处理**：
- 用户选择"诊断正确，继续修复" - 继续执行修复
- 用户选择"诊断有误"或"Other" - 根据反馈修改后重新确认

### 步骤 7：设计修复方案

**操作**：
1. 根据确认的诊断，细化修复方案
2. 确定修改的文件和范围
3. 评估修复的风险

**修复原则**：
- ✅ 最小化修改范围
- ✅ 不引入新的问题
- ✅ 保持与 plan.md 设计的一致性
- ❌ 不借机添加新功能

### 步骤 8：执行修复

**操作**：
1. 按照修复方案修改代码
2. 在代码注释中引用 debug 文档

**代码注释示例**：
```python
# 修复: debug-001.md - 处理空值输入的边界情况
if value is None:
    return default_value
```

### 步骤 9：验证修复结果

**操作**：
1. 复现原问题，确认已修复
2. 运行相关测试
3. 检查是否引入新问题

```bash
# 运行测试
pytest tests/ -v

# 运行特定测试
pytest tests/test_xxx.py -v
```

### 步骤 10：创建 debug-xxx-fix.md 修复总结

**操作**：
1. 在同目录下创建 debug-xxx-fix.md
2. 记录修复内容和验证结果

**Frontmatter 格式（必须）**：

```yaml
---
title: 修复总结-简述
type: debug-fix
category: 与 plan.md 相同
status: 未确认
created: YYYY-MM-DD
plan: "[[plan]]"
debug: "[[debug-001]]"
tags:
  - spec
  - debug-fix
---
```

**修复总结模板**：

```markdown
# 修复总结

## 1. 修复概述

- **关联诊断**：[[debug-001|问题诊断]]
- **修复日期**：YYYY-MM-DD
- **修复人员**：Claude Code

---

## 2. 修复内容

### 2.1 修改的文件

| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `src/xxx.py` | 修改 | [修改说明] |
| `tests/test_xxx.py` | 新增 | [测试说明] |

### 2.2 关键修改

```python
# 修改前
[原代码]

# 修改后
[新代码]
```

---

## 3. 验证结果

### 3.1 问题复现测试
- [x] 原问题已无法复现

### 3.2 回归测试
- [x] 单元测试通过
- [x] 相关功能测试通过

### 3.3 测试结果
```
pytest tests/ -v
===== X passed in X.XXs =====
```

---

## 4. 经验总结

> [!tip] 可记录到 memory
> 如果这是一个有价值的「困境-策略」对，考虑使用 `/memory` 记录。

### 4.1 问题原因
[简要总结问题的根本原因]

### 4.2 预防措施
[如何避免类似问题再次发生]

---

## 5. 文档关联

- 设计文档: [[plan|设计方案]]
- 实现总结: [[summary|实现总结]]
- 问题诊断: [[debug-001|问题诊断]]
```

### 步骤 11：等待用户确认修复

**操作**：
1. 使用 `AskUserQuestion` 工具等待用户确认修复总结

```python
AskUserQuestion(
    questions=[{
        "question": "修复总结已创建，修复结果是否满意？",
        "header": "确认修复",
        "multiSelect": false,
        "options": [
            {
                "label": "修复完成",
                "description": "修复结果满意，问题已解决"
            },
            {
                "label": "需要调整",
                "description": "修复需要进一步调整，请说明要求"
            }
        ]
    }]
)
```

## 文档结构示例

```
spec/03-功能实现/20260122-xxx/
├── plan.md              # 原始设计（保持不变）
├── summary.md           # 实现总结
├── debug-001.md         # 问题诊断文档
└── debug-001-fix.md     # 修复总结文档
```

## 严重程度定义

| 级别 | 定义 | 处理优先级 |
|------|------|------------|
| **高** | 功能完全不可用、数据丢失风险、安全问题 | 立即处理 |
| **中** | 功能部分受影响、有临时解决方案 | 尽快处理 |
| **低** | 边缘情况、UI 问题、非核心功能 | 排期处理 |

## 与其他 Skill 的协作

### 与 spec-executor 的关系

```
spec-executor 执行后发现问题
    ↓
使用 spec-debugger 诊断和修复
    ↓
修复完成后，summary.md 保持不变
debug 文档作为补充记录
```

### 与 spec-updater 的区别

| 场景 | 使用的 Skill |
|------|-------------|
| "我想给这个功能加个新特性" | spec-updater |
| "执行时发现实现有 bug" | spec-debugger |
| "需求理解错了，要重新设计" | 创建新 plan.md |

### 与 exp-reflect 的联动

修复完成后，调用 `/exp-reflect` 进行经验反思，将问题和解决方案沉淀为可复用经验。

---

## 后续动作（工具记忆）

完成问题诊断与修复后，你应该：

### 后续流程
1. 确认修复已通过验证
2. 检查是否需要更新相关测试
3. **调用 `/exp-reflect` 进行经验反思**
4. 如有经验沉淀，更新 debug-xxx-fix.md 添加经验引用

### 常见陷阱
- 直接修改 plan.md 而不是创建 debug 文档
- 忘记创建 debug-xxx-fix.md 修复总结
- 修复时引入了新功能（应使用 spec-updater）
- 未等待用户确认就完成流程
