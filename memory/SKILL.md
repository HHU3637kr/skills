---
name: project-memory
description: 项目长时记忆管理，自动分析对话上下文并记录关键项目知识（架构决策、代码约定、问题解决方案等）。手动触发：/memory，自动提示：在重要决策或问题解决后。
allowed-tools: Read, Write, Edit, Glob, Grep, Bash
model: claude-sonnet-4-5
---

# Project Memory - 项目长时记忆元 Skill

## 概述

这是一个**元 Skill（Meta Skill）**，用于管理 Agent 的长时记忆系统。它不直接存储记忆，而是**引导 Agent 将经验结构化并写入正确的位置**。

基于 MUSE 框架的"反思 → 结构化 → 记忆化"理念，本 Skill 实现三层记忆架构：

```
┌─────────────────────────────────────────────────────────────────┐
│                     MUSE 记忆架构 in Claude Code                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────┐   ┌──────────────────┐   ┌─────────────┐ │
│  │   战略记忆       │   │   程序记忆       │   │  工具记忆   │ │
│  │ Strategic Memory │   │ Procedural Memory│   │ Tool Memory │ │
│  └────────┬─────────┘   └────────┬─────────┘   └──────┬──────┘ │
│           │                      │                    │        │
│           ▼                      ▼                    ▼        │
│     CLAUDE.md              独立的 Skill          Skill 末尾    │
│   （全量系统提示词）      （按需加载正文）      （后续动作指引）│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 三层记忆的 Claude Code 实现

### 1. 战略记忆 → CLAUDE.md

**存储位置**：`CLAUDE.md` 的「战略记忆」章节

**加载方式**：全量注入系统提示词（CLAUDE.md 始终加载）

**内容格式**：`<困境, 策略>` 键值对
```markdown
## 战略记忆

### [日期] 困境标题
- **困境**：遇到了什么问题/挑战
- **策略**：采用了什么解决策略
- **理由**：为什么这个策略有效
```

**写入时机**：
- 重大架构决策后
- 解决了反复出现的困难问题
- 发现了全局性的最佳实践

### 2. 程序记忆 → 独立 Skill

**存储位置**：`.claude/skills/sop-xxx/SKILL.md`

**加载方式**：
- Skill 的 `description` 作为索引（始终可见）
- Skill 的正文作为 SOP 内容（触发时才加载）

**内容格式**：标准 Skill 格式，包含 SOP 步骤
```markdown
---
name: sop-xxx
description: [简短描述，作为索引] 触发条件：[什么时候使用]
---

# SOP: [操作名称]

## 前置条件
...

## 执行步骤
...

## 后续动作（工具记忆）
完成本 SOP 后，你应该：
- [下一步动作1]
- [下一步动作2]
```

**写入时机**：
- 完成了可复用的多步骤操作
- 发现了重复的操作模式
- 用户明确要求记录 SOP

### 3. 工具记忆 → Skill 末尾

**存储位置**：每个 Skill 文件的末尾「后续动作」章节

**加载方式**：随 Skill 一起加载，执行完 Skill 后自动参考

**内容格式**：
```markdown
## 后续动作（工具记忆）

完成本操作后，你应该：
1. [具体的下一步动作]
2. [需要检查的事项]
3. [可能需要调用的其他 Skill]
```

**写入时机**：
- 发现某个操作后总是需要特定的后续步骤
- 工具调用有固定的最佳实践模式

---

## 记忆更新方式

三种记忆类型在更新时，根据新内容与现有内容的关系，采用不同的更新方式：

### 更新方式矩阵

```
                │ 嵌入更新 │ 增量更新 │ 覆盖更新
────────────────┼──────────┼──────────┼──────────
战略记忆        │   不适用  │   ✅     │   ✅
（困境-策略对）  │          │（补充策略）│（纠正错误）
────────────────┼──────────┼──────────┼──────────
程序记忆        │   ✅     │   ✅     │   ✅
（SOP 步骤）     │（过程规范）│（补充步骤）│（纠正流程）
────────────────┼──────────┼──────────┼──────────
工具记忆        │   ✅     │   ✅     │   ✅
（后续动作）     │（过程规范）│（新增动作）│（纠正错误）
```

### 1. 嵌入更新

**含义**：将内容嵌入到操作步骤中，而非放在"后续动作"章节

**适用条件**：
- 内容是"操作过程中应遵循的规范"或"格式要求"
- 不在操作完成后执行，而是在操作执行时就要应用

**适用记忆类型**：程序记忆、工具记忆

**示例**：

```markdown
#### 步骤 5：撰写 plan.md 内容

**操作**：
1. 在与 plan.md 相同的目录下创建 plan.md
2. **撰写时直接应用 Obsidian 格式优化**  ← 嵌入的内容
3. 使用 `Write` 工具保存文件

**Obsidian 格式优化（撰写时应用）**：  ← 嵌入的详细说明
1. 添加内部链接
2. 使用 Callout 突出重要信息
3. 添加标签
```

**判断标准**：
```
Q: 这个内容是在操作"完成后"执行，还是操作"过程中"就要应用？
A: 过程中应用 → 嵌入更新
   完成后执行 → 增量或覆盖更新
```

### 2. 增量更新

**含义**：在现有内容基础上新增，保留原有内容

**适用条件**：
- 新内容与现有内容互补，不冲突
- 新内容增加了新的步骤、检查项或注意事项

**适用记忆类型**：战略记忆、程序记忆、工具记忆

**示例**：

```markdown
### [2026-01-08] WebSocket 连接在长时间任务中断开

- **困境**：评估任务执行时间较长（>60s），WebSocket 连接会超时断开
- **策略**：
  1. 增加 Nginx 的 proxy_read_timeout 到 300s
  2. 前端添加心跳机制，每 30s 发送 ping
  3. 后端支持断线重连
- **理由**：三层防护确保连接稳定，即使断开也能恢复

### [2026-01-09] 多角色页面一致性维护  ← 增量新增

- **困境**：系统支持多角色，部分页面共用、部分分开维护，修改时容易遗漏
- **策略**：共用页面修改时需同时考虑所有角色的使用场景...
```

**判断标准**：
```
Q: 新内容是否与现有内容冲突？
A: 不冲突 → 增量更新
   有冲突 → 覆盖更新
```

### 3. 覆盖更新

**含义**：替换现有内容，删除旧版本

**适用条件**：
- 现有内容过时、错误或不再适用
- 新内容是对原有内容的纠正或改进

**适用记忆类型**：战略记忆、程序记忆、工具记忆

**示例**：

```markdown
## 后续动作（工具记忆）

完成本操作后，你应该：

### 后续流程
1. 创建 summary.md 后，使用 `spec-reviewer` 审查实现  ← 覆盖后的内容
2. 等待用户确认审查报告
3. 用户确认后，将 Spec 文件夹归档到 `06-已归档`
```

**判断标准**：
```
Q: 现有内容是否仍然正确和适用？
A: 是 → 增量更新
   否 → 覆盖更新
```

---

## 更新方式决策树

```
┌─────────────────────────────────────────────────────────────────┐
│                    记忆更新方式决策                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  第一步：判断新内容与现有内容的关系                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Q1: 新内容是否与现有内容冲突或需要纠正？                  │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ A. 是，现有内容错误或过时 → 覆盖更新             │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ B. 否，内容互补或无关 → 继续判断                 │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  第二步：判断内容性质（仅当 Q1 选 B 时）                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Q2: 内容是"操作过程规范"还是"操作后动作"？                │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ A. 操作过程中应遵循的规范                         │    │   │
│  │  │    → 检查记忆类型                                │    │   │
│  │  │       • 程序记忆/工具记忆 → 嵌入更新             │    │   │
│  │  │       • 战略记忆 → 不适用，转为增量更新           │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │                                                          │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │ B. 操作完成后的动作或内容                         │    │   │
│  │  │    → 增量更新                                    │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 反思工作流

当触发 `/memory` 或 `/memory reflect` 时，执行以下流程：

```
反思工作流：
- [ ] 步骤 1：回溯执行轨迹
      - 回顾本次对话中的所有操作
      - 识别关键决策点和转折点
      - 标记成功/失败的尝试

- [ ] 步骤 2：检查现有记忆（防止重复）⚠️ 重要
      - 读取 CLAUDE.md 的「战略记忆」章节
      - 列出 .claude/skills/ 下所有 sop-* 目录
      - 检查待添加的经验是否已存在或高度相似
      - 如果已存在，考虑是否需要更新而非新增

- [ ] 步骤 3：分析可提取的经验
      - 是否有新的「困境-策略」对？→ 战略记忆
      - 是否形成了可复用的 SOP？→ 程序记忆
      - 是否发现了操作后的固定后续步骤？→ 工具记忆

      **[重要] 判断更新方式**（见「记忆更新方式」章节）：
      - Q1: 新内容是否与现有内容冲突或需要纠正？
        • 是 → 覆盖更新
        • 否 → 继续 Q2
      - Q2: 内容是"操作过程规范"还是"操作后动作"？
        • 过程规范 → 检查记忆类型
          - 程序记忆/工具记忆 → 嵌入更新
          - 战略记忆 → 不适用，转为增量更新
        • 操作后动作 → 增量更新

- [ ] 步骤 4：向用户确认
      - 展示提取的经验
      - 说明将写入的位置
      - 如果存在相似记忆，明确告知用户并询问是「更新」还是「新增」
      - 获得用户确认

- [ ] 步骤 5：执行写入
      - 根据步骤 3 确定的更新方式执行：
      - **嵌入更新**：将内容嵌入到操作步骤中
        • 程序记忆 → 编辑 Skill 的执行步骤
        • 工具记忆 → 编辑 Skill 的操作步骤
      - **增量更新**：在现有内容基础上新增
        • 战略记忆 → 追加到 CLAUDE.md 战略记忆章节
        • 程序记忆 → 新增 SOP 步骤或创建新 Skill
        • 工具记忆 → 追加到 Skill 的"后续动作"章节
      - **覆盖更新**：替换现有内容
        • 战略记忆 → 替换 CLAUDE.md 中的对应条目
        • 程序记忆 → 替换 Skill 中的对应步骤
        • 工具记忆 → 替换 Skill 的"后续动作"章节

- [ ] 步骤 6：确认完成
      - 告知用户记忆已保存
      - 说明如何触发/使用这些记忆
```

---

## ⚠️ 防止重复记忆规则

### 核心原则

**在添加任何记忆之前，必须先检查是否已存在相同或相似的记忆。**

### 检查流程

#### 1. 战略记忆去重

添加战略记忆前，必须：

```
1. 读取 CLAUDE.md 文件
2. 定位「战略记忆」章节
3. 检查是否存在相同或相似的「困境」
4. 判断结果：
   - 完全相同 → 不添加，告知用户已存在
   - 相似但有差异 → 询问用户是「更新现有」还是「新增」
   - 不存在 → 可以添加
```

**相似性判断标准**：
- 困境描述的核心问题相同
- 策略的主要方法相同
- 适用场景相同

#### 2. 程序记忆（SOP）去重

创建 SOP Skill 前，必须：

```
1. 列出 .claude/skills/ 下所有 sop-* 目录
2. 读取每个 SOP 的 description（索引）
3. 检查是否存在相同或相似的 SOP
4. 判断结果：
   - 完全相同 → 不创建，告知用户已存在
   - 相似但有差异 → 询问用户是「更新现有」还是「新增」
   - 不存在 → 可以创建
```

**相似性判断标准**：
- SOP 名称相似
- 触发条件相同
- 核心步骤相同

#### 3. 工具记忆去重

添加工具记忆前，必须：

```
1. 读取目标 Skill 文件
2. 检查「后续动作」章节是否已存在
3. 检查待添加的后续动作是否已包含
4. 判断结果：
   - 已存在相同动作 → 不添加
   - 存在但不完整 → 补充完善
   - 不存在 → 可以添加
```

### 用户交互示例

#### 示例 1：发现重复的战略记忆

```
Agent：我注意到这次解决了 WebSocket 连接问题，准备记录到战略记忆...

[检查现有记忆]

Agent：检查发现 CLAUDE.md 中已存在相似的战略记忆：

**现有记忆**：[2026-01-08] WebSocket 连接在长时间任务中断开
- 困境：评估任务执行时间较长（>60s），WebSocket 连接会超时断开
- 策略：三层防护（Nginx 超时 + 心跳 + 重连）

**本次经验**与现有记忆高度相似，无需重复添加。

如果你认为有新的补充内容，请告诉我，我可以更新现有记忆。
```

#### 示例 2：发现相似的 SOP

```
Agent：这次部署流程可以记录为 SOP...

[检查现有 SOP]

Agent：检查发现已存在相似的 SOP：

**现有 SOP**：sop-003-deployment
- 描述：应用部署流程
- 触发条件：需要部署应用

本次流程与现有 SOP 相似。请选择：
1. 更新现有 SOP（添加新步骤或修改）
2. 创建新 SOP（如果场景确实不同）
3. 不记录（现有 SOP 已足够）
```

### 检查命令

| 命令 | 说明 |
|------|------|
| `/memory check` | 检查现有记忆，不添加新内容 |
| `/memory check strategic` | 仅检查战略记忆 |
| `/memory check sop` | 仅检查 SOP Skill |

---

## 命令参考

| 命令 | 说明 |
|------|------|
| `/memory` | 进入记忆管理模式，分析当前对话 |
| `/memory reflect` | 触发反思，提取可记录的经验 |
| `/memory strategic` | 查看 CLAUDE.md 中的战略记忆 |
| `/memory sop` | 列出所有 SOP Skill |
| `/memory add strategic` | 添加战略记忆到 CLAUDE.md |
| `/memory add sop` | 创建新的 SOP Skill |

---

## 战略记忆写入指南

### 写入位置

编辑 `CLAUDE.md`，在「战略记忆」章节添加新条目。

### 写入格式

```markdown
### [YYYY-MM-DD] 困境标题

- **困境**：[描述遇到的问题或挑战]
- **策略**：[采用的解决策略]
- **理由**：[为什么这个策略有效]
```

### 示例

```markdown
### [2026-01-08] WebSocket 连接在长时间任务中断开

- **困境**：评估任务执行时间较长（>60s），WebSocket 连接会超时断开
- **策略**：
  1. 增加 Nginx 的 proxy_read_timeout 到 300s
  2. 前端添加心跳机制，每 30s 发送 ping
  3. 后端支持断线重连
- **理由**：三层防护确保连接稳定，即使断开也能恢复
```

### 质量原则

1. **精炼**：每条记忆简洁有力，避免冗余
2. **可操作**：策略必须具体可执行
3. **通用性**：优先记录可复用的经验，而非一次性解决方案

---

## 程序记忆（SOP Skill）创建指南

### 创建方式

**推荐**：使用 `/skill-creator` Skill 来创建新的 SOP Skill，它会引导你完成整个创建过程，确保 Skill 结构规范、质量达标。

```
Agent：检测到需要创建新的 SOP Skill，正在调用 /skill-creator...
```

### 创建位置

`.claude/skills/sop-[编号]-[简短名称]/SKILL.md`

### Skill 模板

```markdown
---
name: sop-[编号]-[简短名称]
description: [一句话描述 SOP 用途]。触发条件：[什么时候使用这个 SOP]
allowed-tools: [需要的工具列表]
---

# SOP: [操作名称]

## 概述

[简要说明这个 SOP 的目的和适用场景]

## 前置条件

- [ ] [条件1]
- [ ] [条件2]

## 执行步骤

### 步骤 1: [步骤名称]

**操作**：[具体操作]

**验证**：[如何验证步骤完成]

**异常处理**：[如果失败怎么办]

### 步骤 2: [步骤名称]

...

## 后置检查

- [ ] [检查项1]
- [ ] [检查项2]

## 常见问题

### Q1: [问题]
A: [答案]

---

## 后续动作（工具记忆）

完成本 SOP 后，你应该：
1. [下一步动作]
2. [需要检查的事项]
3. [可能需要调用的其他 Skill]
```

### 命名规范

- 编号：三位数字，如 `001`、`002`
- 名称：简短的英文或拼音，用连字符分隔
- 示例：`sop-001-spec-driven-dev`、`sop-002-bug-fix`

### 质量原则

1. **可重复**：步骤必须足够详细，能够重复执行
2. **有验证**：每个步骤都有验证方法
3. **有后续**：末尾必须包含「后续动作」章节

---

## 工具记忆嵌入指南

### 嵌入位置决策

工具记忆的嵌入位置取决于内容性质：

| 内容性质 | 位置 | 更新方式 | 示例 |
|----------|------|----------|------|
| **操作过程规范** | 嵌入到操作步骤中 | 嵌入更新 | 撰写文档时应用 Obsidian 格式 |
| **操作后动作** | Skill 末尾"后续动作"章节 | 增量/覆盖更新 | 提交后检查 CI/CD |

#### 判断标准

```
Q: 这个内容是在操作"完成后"执行，还是操作"过程中"就要应用？

A: 过程中应用 → 嵌入更新（嵌入到操作步骤中）
   完成后执行 → 增量/覆盖更新（保留在"后续动作"章节）
```

### 1. 嵌入更新格式（操作过程规范）

当内容是操作过程中应遵循的规范时，**嵌入到对应的操作步骤中**：

```markdown
#### 步骤 X：[步骤名称]

**操作**：
1. [操作 1]
2. **撰写时直接应用 [格式/规范名称]**  ← 指向嵌入内容
3. [操作 3]

**[格式/规范名称]（撰写时应用）**：  ← 嵌入的详细说明
1. [规范项 1]
2. [规范项 2]
3. [规范项 3]

**相关 Skill**：
- `/相关-skill` - [说明]
```

### 2. 增量/覆盖更新格式（操作后动作）

当内容是操作完成后执行的动作时，**放在 Skill 末尾的"后续动作"章节**：

```markdown
---

## 后续动作（工具记忆）

完成本操作后，你应该：

### 后续流程
1. [下一步动作 1]
2. [下一步动作 2]

### 相关 Skill
- `/sop-xxx` - [相关 SOP 描述]
```

### 示例对比

#### 嵌入更新示例

```markdown
#### 步骤 5：撰写 plan.md 内容

**操作**：
1. 在与 plan.md 相同的目录下创建 plan.md
2. **撰写时直接应用 Obsidian 格式优化**
3. 使用 `Write` 工具保存文件

**Obsidian 格式优化（撰写时应用）**：
1. 添加内部链接
2. 使用 Callout 突出重要信息
3. 添加标签
```

#### 增量更新示例

```markdown
---

## 后续动作（工具记忆）

完成 Spec 执行后，你应该：

### 后续流程
1. 创建 summary.md 后，使用 `spec-reviewer` 审查实现
2. 等待用户确认审查报告
3. 用户确认后，将 Spec 文件夹归档到 `06-已归档`

### 记忆更新提示
如果在实现过程中发现了重要的「困境-策略」对，考虑使用 `/memory` Skill 记录。
```

---

## 自动提示规则

Agent 应在以下场景**主动询问**是否需要记录：

### 战略记忆触发信号

- 解决了一个反复出现的困难问题
- 做出了重要的架构或技术决策
- 发现了一个全局性的最佳实践
- 用户说"以后都这样处理"

### 程序记忆触发信号

- 完成了一个多步骤的复杂操作（>5 步）
- 发现自己在重复类似的操作序列
- 成功解决了一个需要特定流程的问题
- 用户说"记录一下这个流程"

### 工具记忆触发信号

- 发现某个操作后总是需要特定的后续步骤
- 工具调用有固定的检查或验证模式
- 一个 Skill 执行后经常需要调用另一个 Skill

---

## 与现有 Skill 的协作

### 与 spec-writer 协作

- 创建 Spec 时，可参考 CLAUDE.md 中的战略记忆
- 如果 Spec 创建流程形成固定模式，可提取为 SOP Skill

### 与 spec-executor 协作

- 执行 Spec 时，可参考相关的 SOP Skill
- 执行完成后，可触发反思提取新的经验

### 与 git-workflow-sop 协作

- Git 操作的最佳实践可作为工具记忆嵌入
- 复杂的 Git 流程可提取为独立的 SOP Skill

---

## 示例场景

### 场景 1：添加战略记忆

```
[解决了 WebSocket 连接问题后]

Agent：我注意到我们刚刚解决了一个关于 WebSocket 连接超时的问题。
这是一个「困境-策略」对，建议记录到战略记忆中。

**困境**：WebSocket 在长时间任务中断开
**策略**：三层防护（Nginx 超时 + 心跳 + 重连）

是否将此添加到 CLAUDE.md 的战略记忆章节？

用户：好的

Agent：正在编辑 CLAUDE.md...
已添加战略记忆：[2026-01-08] WebSocket 连接在长时间任务中断开
```

### 场景 2：创建 SOP Skill

```
[完成了一个复杂的部署流程后]

Agent：我注意到这次部署涉及 8 个步骤，形成了一个可复用的流程。
建议创建一个 SOP Skill 来记录这个流程。

**SOP 名称**：sop-004-deployment
**触发条件**：需要部署应用到生产环境
**主要步骤**：
1. 检查测试通过
2. 构建生产版本
3. 备份当前版本
...

是否创建这个 SOP Skill？

用户：是的

Agent：正在调用 /skill-creator 创建 SOP Skill...
[skill-creator 引导完成 Skill 创建]
已创建 SOP Skill。以后可以通过 `/sop-004-deployment` 触发。
```

### 场景 3：添加工具记忆

```
[发现每次运行测试后都需要检查覆盖率]

Agent：我注意到每次运行测试后，我们都会检查覆盖率报告。
建议将这个后续动作添加到相关 Skill 的工具记忆中。

是否更新 sop-002-bug-fix 的「后续动作」章节？

用户：好的

Agent：正在编辑 .claude/skills/sop-002-bug-fix/SKILL.md...
已添加工具记忆：测试通过后检查覆盖率报告
```

---

## 记忆系统维护

### 定期清理

- 删除过时的战略记忆
- 合并重复的 SOP Skill
- 更新不再适用的工具记忆

### 质量检查

- 战略记忆是否仍然有效？
- SOP 步骤是否需要更新？
- 工具记忆的后续动作是否准确？

### 版本控制

所有记忆文件都随项目代码一起进行 Git 版本管理，确保：
- 记忆的变更可追溯
- 团队成员可共享记忆
- 可以回滚错误的记忆更新
